{"data":{"markdownRemark":{"html":"<h2>What is Caching</h2>\n<p>Caching is the concept of intelligently storing commonly-used data in quick-to-access locations so that requesting that data will happen as fast as possible. There are multiple types of caches out there such as CPU cache, GPU cache, disc cache, etc. </p>\n<p>When a requested resource is found in cache, it’s called a <strong>cache hit</strong>. Similarly, if a resource is not found in cache and had to be fully requested from its normal location, it’s called a <strong>cache miss</strong>.</p>\n<p>For the purposes of browser caching, each browser has its own web cache, which is where resources like images and other web page assets are stored for quick access later on. The goal of browser caching is to save you time when requesting the same resource multiple times, and to save bandwidth by reducing the amount of data you request over a network.</p>\n<h2>How Does the Browser Know What to Cache?</h2>\n<p>There are two modern HTTP response headers that define how a resource should be cached: Cache-Control and ETag.</p>\n<h3>Cache-Control</h3>\n<p>When your browser requests resources from a server the first time, it stores the returning resources in its cache according to this header. when your browser needs to request that resource again, it will check its cache to see if the resource is there and that it still fits the Cache-Control specs.</p>\n<p>The Cache-Control header has a couple different parameters that can be set from the server:</p>\n<h4><code class=\"language-text\">no-cache</code> or <code class=\"language-text\">no-store</code></h4>\n<p><strong><code class=\"language-text\">no-cache</code></strong>: This resource should always be requested from the server instead of automatically loaded from cache. However, the protocol about ETags still applies, and if the ETags for the client version and the server version match up then the server will instruct the client to use its cached version.</p>\n<p><strong><code class=\"language-text\">no-store</code></strong>: is simpler in that it tells the browser to always request the resource from the server without checking ETags.</p>\n<h4><code class=\"language-text\">public</code> or <code class=\"language-text\">private</code></h4>\n<p><strong>public</strong> means that a resource can be cached by anyone – but this usually isn’t necessary as by default, defining the max-age part of the header will also set it as public.</p>\n<p><strong>private</strong> means that only the user’s browser can cache the resource, and not any intermediaries such as a CDN. This is especially important when dealing with resources with personal information, such as when you log into your bank’s website.</p>\n<h4><code class=\"language-text\">max-age</code></h4>\n<p>Finally, <strong>max-age</strong> determines the length of time in seconds that this resource should be cached. max-age=120 means that this resource can be cached and reused for 2 minutes.</p>\n<h3>ETag</h3>\n<p>The <strong>ETag</strong> header (short for entity-tag) provides a revalidation token that is automatically sent by the browser to check if the resource has changed since the last time it was requested.</p>\n<p>With ETags, we do have to make a request to the server, but instead of re-downloading the entire resource, our goal is to check with the server to see if there’s been any modifications to it. If there haven’t been, then the server responds back with a 304 response code – meaning “Not-Modified” – and then the browser loads the file from its own cache instead. </p>\n<p><img src=\"https://i2.wp.com/thecodeboss.dev/wp-content/uploads/2015/10/etag-example.png?w=441&#x26;ssl=1\" alt=\"ETag\"></p>\n<h3>Building a Proper Cache Policy</h3>\n<p>Google came up with a nice decision tree to help you figure out what to cache, and for how long.</p>\n<p>??</p>\n<h3>Things we didn't cover</h3>\n<p>There are two HTTP headers that are also related to browser caching that we didn’t cover simply because they’re older and are on their way towards becoming deprecated.</p>\n<ul>\n<li>the <strong>Expires</strong> header – a pre-HTTP 1.1 header\nis a header which prevents the client from requesting the resource again from the server until it “expires” in freshness; it has been replaced by Cache-Control.</li>\n<li>the <strong>Last-Modified</strong> header – also a pre-HTTP 1.1 header\nis a header which also contains an HTTP date stating when the resource was last modified; it has been replaced by ETag</li>\n</ul>","frontmatter":{"date":"July 05, 2019","path":"browser-caching","category":"frontend","title":"Browser Caching"}}},"pageContext":{"location":"browser-caching","category":"frontend"}}